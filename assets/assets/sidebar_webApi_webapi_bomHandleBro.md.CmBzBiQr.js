import{_ as l,c as e,a2 as i,o as t}from"./chunks/framework.D3LXhGAZ.js";const b=JSON.parse('{"title":"BOM浏览器对象模型","description":"","frontmatter":{},"headers":[],"relativePath":"sidebar/webApi/webapi/bomHandleBro.md","filePath":"sidebar/webApi/webapi/bomHandleBro.md"}'),a={name:"sidebar/webApi/webapi/bomHandleBro.md"};function c(d,o,s,r,n,u){return t(),e("div",null,o[0]||(o[0]=[i('<h1 id="bom浏览器对象模型" tabindex="-1">BOM浏览器对象模型 <a class="header-anchor" href="#bom浏览器对象模型" aria-label="Permalink to &quot;BOM浏览器对象模型&quot;">​</a></h1><h2 id="window对象事件" tabindex="-1">window对象事件 <a class="header-anchor" href="#window对象事件" aria-label="Permalink to &quot;window对象事件&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li><code>window.onload = function(){ script代码 }</code></li></ol><blockquote><ul><li>页面加载事件，等页面上所有资源加载完毕后再执行</li></ul></blockquote><p> </p><ol start="2"><li><code>window.onbeforeunload = function(){ script代码 }</code></li></ol><blockquote><ul><li>页面关闭之前事件，一般用来保存一些重要的数据</li></ul></blockquote></div><p> </p><h2 id="window方法" tabindex="-1">window方法 <a class="header-anchor" href="#window方法" aria-label="Permalink to &quot;window方法&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li><code>window.open()</code>：打开窗口</li></ol><blockquote><ul><li><code>window.open(&#39;https://&#39;, &#39;_self&#39;, &#39;width=400, height=400, top=200, left=200&#39;, true)</code></li></ul><blockquote><ul><li>https://：窗口地址</li><li>_self：窗口名称，默认为当前窗口；_blank：新窗口； _parent：父窗口； _top：最顶层窗口</li><li>width：窗口宽度</li><li>height：窗口高度</li><li>top：窗口距离顶部的距离</li><li>left：窗口距离左侧的距离</li><li>true：窗口是否新开窗；</li></ul></blockquote></blockquote><p> </p><ol start="2"><li><code>window.close()</code>：关闭窗口</li></ol><blockquote><ul><li>页面关闭之前事件，一般用来保存一些重要的数据</li></ul></blockquote></div><p> </p><h2 id="window五大对象" tabindex="-1">window五大对象 <a class="header-anchor" href="#window五大对象" aria-label="Permalink to &quot;window五大对象&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><h4 id="_1-document" tabindex="-1">1. <code>document</code> <a class="header-anchor" href="#_1-document" aria-label="Permalink to &quot;1. `document`&quot;">​</a></h4><ol><li>作用：网页的内容（即 DOM 文档对象模型）</li><li>属性：</li></ol><blockquote><ul><li><code>document.getElementById(&quot;myElement&quot;)</code>：通过元素的 id 属性获取页面元素</li><li><code>document.getElementsByClassName(&quot;myClass&quot;)</code>：通过类名获取元素，返回一个html集合对象</li><li><code>document.getElementsByTagName(&quot;标签名&quot;)</code>：通过标签名获取元素，返回一个html集合对象</li><li><code>document.querySelector(&quot;选择器&quot;)</code>：获取第一个匹配的元素</li><li><code>document.querySelectorAll(&quot;选择器&quot;)</code>：获取所有匹配的元素，返回一个 NodeList</li></ul></blockquote><p> </p><h4 id="_2-location" tabindex="-1">2. <code>location</code> <a class="header-anchor" href="#_2-location" aria-label="Permalink to &quot;2. `location`&quot;">​</a></h4><ol><li>作用：获取地址，包含当前有关URL的信息</li><li>属性：</li></ol><blockquote><ul><li><code>herf</code>：获取/设置路径</li><li><code>search</code>：获取/设置从问号“?”开始的URL（查询部分）</li><li><code>hash</code>：获取/设置从井号“#”开始的 URL（锚）</li></ul></blockquote><ol start="3"><li>方法：</li></ol><blockquote><ul><li><code>location.assign(&#39;地址&#39;)</code>：加载新的文档（跳转）</li><li><code>location.replace(&#39;地址&#39;)</code>：替换当前文档</li><li><code>location.reload()</code>：刷新</li></ul></blockquote><p> </p><h4 id="_3-history" tabindex="-1">3. <code>history</code> <a class="header-anchor" href="#_3-history" aria-label="Permalink to &quot;3. `history`&quot;">​</a></h4><ol><li>作用：包含用户（在浏览器窗口中）访问过的 URL</li><li>属性：</li></ol><blockquote><ul><li><code>length</code>：返回浏览器历史列表中的URL数量</li></ul></blockquote><ol start="3"><li>方法：</li></ol><blockquote><ul><li><code>history.back()</code>：返回上一个URL</li><li><code>history.forward()</code>： 前进一个URL</li></ul></blockquote><p> </p><h4 id="_4-navigator" tabindex="-1">4. <code>navigator</code> <a class="header-anchor" href="#_4-navigator" aria-label="Permalink to &quot;4. `navigator`&quot;">​</a></h4><ol><li>作用：包含有关浏览器的信息</li><li>属性：</li></ol><blockquote><ul><li><code>navigator.userAgent</code>：浏览器用户头部信息,可以用他去判断打开当前页面的是什么浏览器</li></ul></blockquote><p> </p><h4 id="_5-screen" tabindex="-1">5. <code>screen</code> <a class="header-anchor" href="#_5-screen" aria-label="Permalink to &quot;5. `screen`&quot;">​</a></h4><ol><li>作用：包含有关客户端显示屏幕的信息</li><li>属性：</li></ol><blockquote><ul><li><code>screen.width</code>：返回显示屏幕的宽</li><li><code>screen.height</code>：返回显示屏幕的高</li><li><code>screen.availWidth</code>：不含任务栏屏幕的宽</li><li><code>screen.availHeight</code>：不含任务栏屏幕的高</li></ul></blockquote></div><p> </p><h2 id="存储对象localstorage与sessionstorage" tabindex="-1">存储对象localStorage与sessionStorage <a class="header-anchor" href="#存储对象localstorage与sessionstorage" aria-label="Permalink to &quot;存储对象localStorage与sessionStorage&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><h4 id="_1-localstorage" tabindex="-1">1. <code>localStorage</code> <a class="header-anchor" href="#_1-localstorage" aria-label="Permalink to &quot;1. `localStorage`&quot;">​</a></h4><ol><li>作用：本地永久存储</li><li>方法：</li></ol><blockquote><ul><li><code>localStorage.setItem(&#39;键&#39;,&#39;值&#39;)</code>：存储数据</li><li><code>localStorage.getItem(&#39;键&#39;)</code>：读取数据</li><li><code>localStorage.removeItem(&#39;键&#39;)</code>：删除数据</li><li><code>localStorage.clear();</code>：清空数据</li></ul></blockquote><ol start="3"><li>注意：</li></ol><blockquote><ul><li>localStorage只能存放字符串格式的数据，存的时候是其他类型的数据，取的时候是字符串；</li><li>永久存储(存到了硬盘中)，除非硬盘坏了，或者手动删除了，不然一直都在（生命周期永久生效）</li></ul></blockquote><p> </p><h4 id="_2-sessionstorage" tabindex="-1">2. <code>sessionStorage</code> <a class="header-anchor" href="#_2-sessionstorage" aria-label="Permalink to &quot;2. `sessionStorage`&quot;">​</a></h4><ol><li>作用：本地临时存储</li><li>方法：</li></ol><blockquote><ul><li><code>sessionStorage.setItem(&#39;键&#39;,&#39;值&#39;)</code>：存储数据</li><li><code>sessionStorage.getItem(&#39;键&#39;)</code>：读取数据</li><li><code>sessionStorage.removeItem(&#39;键&#39;)</code>：删除数据</li><li><code>sessionStorage.clear();</code>：清空数据</li></ul></blockquote><ol start="3"><li>注意：</li></ol><blockquote><ul><li>只能存放字符串格式的值；</li><li>临时存储，存在内存中了，如果页面关闭数据就清空了</li><li>sessionStorage只在同一浏览器窗口或标签页中有效</li><li>跨域的页面无法访问同一会话存储的数据</li></ul></blockquote><p> </p><h4 id="对象类型数据的本地存储问题" tabindex="-1">对象类型数据的本地存储问题 <a class="header-anchor" href="#对象类型数据的本地存储问题" aria-label="Permalink to &quot;对象类型数据的本地存储问题&quot;">​</a></h4><ol><li>背景：本地存储只能存放字符串格式的值</li><li>解决：</li></ol><blockquote><ol><li>存储时：js对象 → <code>JSON.stringify(obj)</code> → 本地存储</li><li>读取时：本地数据 → <code>JSON.parse(str)</code> → js对象</li></ol><blockquote><ul><li>json格式数据</li></ul><blockquote><ol><li>组成：</li></ol><blockquote><ol><li>本质是一个字符串</li><li>最外层只能是[ ]或者</li><li>json文件中不能写注释</li></ol></blockquote></blockquote><blockquote><ol start="2"><li>特点：键和字符串数据必须要用双引号给引起来</li></ol></blockquote><blockquote><ol start="3"><li>注意：值不能是undefined和function函数</li></ol></blockquote><blockquote><ol start="4"><li>转换：</li></ol><blockquote><ol><li>json格式的数据转成js对象：JSON.parse()</li><li>js对象转成json格式的数据：JSON.stringify()</li></ol></blockquote></blockquote></blockquote></blockquote><p> </p><h4 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h4><ul><li>在同一域下的多个页面（如页面 A 和页面 B）之间，可以使用 sessionStorage 实现数据共享。sessionStorage 是在同一会话中共享的，页面刷新或页面间跳转不会清除数据，但关闭浏览器或标签页后会清空数据</li></ul></div><p> </p><h2 id="屏幕三大家族" tabindex="-1">屏幕三大家族 <a class="header-anchor" href="#屏幕三大家族" aria-label="Permalink to &quot;屏幕三大家族&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><h4 id="_1-offset" tabindex="-1">1. <code>offset</code> <a class="header-anchor" href="#_1-offset" aria-label="Permalink to &quot;1. `offset`&quot;">​</a></h4><ol><li><code>offsetParent</code>：找到自己最近一级有定位的祖先元素</li></ol><blockquote><ul><li>如果自己有固定定位，那该元素的offsetParent为null；</li><li>如果自己没有固定定位，祖先级没有定位，那该元素的offsetParent是body；</li><li>如果自己没有固定定位，祖先级有定位，那该元素的offsetParent是离自己最近有固定定位的祖先元素；</li><li>body的offsetParent为null</li></ul></blockquote><ol start="2"><li><code>offsetLeft</code>：自己的左外边框到该盒子的offsetParent的左内边框的距离</li><li><code>offsetTop</code>：自己的上外边框到该盒子的offsetParent的上内边框的距离</li><li><code>offsetWidth</code>：盒子除去外边距时的宽度</li><li><code>offsetHeight</code>：盒子除去外边距时的高度</li></ol><p> </p><h4 id="_2-scroll" tabindex="-1">2. <code>scroll</code> <a class="header-anchor" href="#_2-scroll" aria-label="Permalink to &quot;2. `scroll`&quot;">​</a></h4><ol><li><code>scrollLeft</code>：元素左边被隐藏的内容+盒子边框</li><li><code>scrollTop</code>：元素上边被隐藏的内容+盒子边框</li><li><code>scrollWidth</code>：内容的真实宽度</li><li><code>scrollHeight</code>：内容的真实高度</li><li><code>document.documentElement.scrollLeft</code>：获取页面左边滚出去的距离</li><li><code>document.documentElement.scrollTeft</code>：获取页面上边滚出去的距离</li></ol><p> </p><h4 id="_3-client" tabindex="-1">3. <code>client</code> <a class="header-anchor" href="#_3-client" aria-label="Permalink to &quot;3. `client`&quot;">​</a></h4><ol><li><code>clientWidth</code>：除去边框之外的宽度</li><li><code>clientHeight</code>：除去边框之外的高度</li></ol></div>',15)]))}const q=l(a,[["render",c]]);export{b as __pageData,q as default};
