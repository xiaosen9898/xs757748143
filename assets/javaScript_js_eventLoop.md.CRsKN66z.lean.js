import{_ as t,c as o,a4 as a,o as i}from"./chunks/framework.BvVMNBiX.js";const h=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"javaScript/js/eventLoop.md","filePath":"javaScript/js/eventLoop.md"}'),e={name:"javaScript/js/eventLoop.md"};function s(c,l,r,p,n,u){return i(),o("div",null,l[0]||(l[0]=[a('<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h1><h2 id="进程与线程" tabindex="-1">进程与线程 <a class="header-anchor" href="#进程与线程" aria-label="Permalink to &quot;进程与线程&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>进程：程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程。每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意</li></ol><p> </p><ol start="2"><li>线程：一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程</li></ol></div><p> </p><h2 id="浏览器中的主要进程与线程" tabindex="-1">浏览器中的主要进程与线程 <a class="header-anchor" href="#浏览器中的主要进程与线程" aria-label="Permalink to &quot;浏览器中的主要进程与线程&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>浏览器进程：主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务</li></ol><p> </p><ol start="2"><li>网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</li></ol><p> </p><ol start="3"><li>渲染进程：渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码</li></ol><blockquote><ol><li>解析 HTML、解析 CSS、计算样式、布局、处理图层</li><li>每秒把页面画 60 次</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>......</li></ol></blockquote><blockquote><ul><li>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响</li></ul></blockquote></div><p> </p><h2 id="事件循环-1" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环-1" aria-label="Permalink to &quot;事件循环&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>背景：为什么渲染进程不适用多个线程来处理这些事情？</li></ol><blockquote><p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p></blockquote><p> </p><ol start="2"><li>事件循环：</li></ol><blockquote><ol><li>在最开始的时候，渲染主线程会进入一个无限循环；</li><li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态；</li><li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li></ol></blockquote></div><p> </p><h2 id="主要的任务队列" tabindex="-1">主要的任务队列 <a class="header-anchor" href="#主要的任务队列" aria-label="Permalink to &quot;主要的任务队列&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>微队列：用户存放需要最快执行的任务，优先级「优先级最高」</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li></ol><p>注意：任务是没有优先级的，但是任务队列有优先级</p></div>',12)]))}const b=t(e,[["render",s]]);export{h as __pageData,b as default};
