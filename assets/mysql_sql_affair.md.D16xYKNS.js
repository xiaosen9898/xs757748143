import{_ as t,c as a,a2 as l,o as s}from"./chunks/framework.D3LXhGAZ.js";const k=JSON.parse('{"title":"事务","description":"","frontmatter":{},"headers":[],"relativePath":"mysql/sql/affair.md","filePath":"mysql/sql/affair.md"}'),e={name:"mysql/sql/affair.md"};function o(d,i,h,p,r,c){return s(),a("div",null,i[0]||(i[0]=[l('<h1 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ul><li><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p></li><li><p>默认mysql的事务是自动提交的，也就是说，当执行一条DML语句，mysql会立即隐式地提交事务</p></li></ul></div><p> </p><h2 id="事务操作" tabindex="-1">事务操作 <a class="header-anchor" href="#事务操作" aria-label="Permalink to &quot;事务操作&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>方式1：</li></ol><blockquote><ol><li>查看事务提交方式：<code>select @@autocommit;</code></li><li>设置事务提交方式：<code>set @@autocommit = XXX;</code></li></ol><blockquote><ul><li>值为1时，为自动提交事务</li><li>值为0时，为手动提交事务</li></ul></blockquote><ol start="3"><li>提交事务：<code>commit;</code></li><li>回滚事务：<code>rollback;</code></li></ol></blockquote><p> </p><ol start="2"><li>方式2：</li></ol><blockquote><ol><li>开启事务：<code>start transaction;</code></li><li>提交事务：<code>commit;</code></li><li>回滚事务：<code>rollback;</code></li></ol></blockquote></div><p> </p><h2 id="事务四大特性" tabindex="-1">事务四大特性 <a class="header-anchor" href="#事务四大特性" aria-label="Permalink to &quot;事务四大特性&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ol></div><p> </p><h2 id="并发事务问题" tabindex="-1">并发事务问题 <a class="header-anchor" href="#并发事务问题" aria-label="Permalink to &quot;并发事务问题&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>脏读：一个事务读到另一个事务还没有提交的数据</li><li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”</li></ol></div><p> </p><h2 id="并发事务问题-1" tabindex="-1">并发事务问题 <a class="header-anchor" href="#并发事务问题-1" aria-label="Permalink to &quot;并发事务问题&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>级别：</li></ol><table tabindex="0"><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read （默认）</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p> </p><ol start="2"><li>查看事务隔离级别：</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @@transaction_isolation;</span></span></code></pre></div><p> </p><ol start="3"><li>设置事务隔离级别：</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [session | global] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">transaction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> isolation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">read</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uncommitted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">read</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> committed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">repeatable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></div>',15)]))}const u=t(e,[["render",o]]);export{k as __pageData,u as default};
