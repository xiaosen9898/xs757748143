import{_ as i,c as a,a4 as l,o as e}from"./chunks/framework.BvVMNBiX.js";const d=JSON.parse('{"title":"同源与跨域","description":"","frontmatter":{},"headers":[],"relativePath":"network/net/cors.md","filePath":"network/net/cors.md"}'),t={name:"network/net/cors.md"};function n(o,s,p,r,h,c){return e(),a("div",null,s[0]||(s[0]=[l(`<h1 id="同源与跨域" tabindex="-1">同源与跨域 <a class="header-anchor" href="#同源与跨域" aria-label="Permalink to &quot;同源与跨域&quot;">​</a></h1><h2 id="同源" tabindex="-1">同源 <a class="header-anchor" href="#同源" aria-label="Permalink to &quot;同源&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>概念：协议、域名(IP)、端口都一致则同源，否则跨域</li></ol><blockquote><ul><li><strong>页面的源和请求目标的源应该保持一致</strong>，如果不一致，就产生了跨域</li></ul></blockquote><ol start="2"><li>特性：</li></ol><blockquote><ol><li>浏览器的安全策略；</li><li>允许客户端向服务器发起请求，也能请求到服务器的数据，但是请求的响应结果会被浏览器拦截</li></ol></blockquote></div><p> </p><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><h4 id="_1-代理服务器" tabindex="-1">1. 代理服务器 <a class="header-anchor" href="#_1-代理服务器" aria-label="Permalink to &quot;1. 代理服务器&quot;">​</a></h4><blockquote><ol><li>说明：跨域问题一般是在开发阶段；</li><li>原理：服务器端没有跨域的限制，所以可以借助一个服务器 A 向另外一个服务器 B 发起请求，服务器 A 就称为代理服务器；</li><li>代理服务器：</li></ol><blockquote><ol><li>在 webpack.config.js 中配置代理服务器:</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">devServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;/api&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当请求地址以 api 开头时，代理到另一个地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://xxx.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 代理的目标地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      changeOrigin: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更改请求头中的host</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></blockquote><blockquote><ol start="2"><li>请求时:</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/api/list&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></blockquote><blockquote><p><code> http://localhost:8080/</code> → <code>http://localhost:8080/api/list</code> → <code>http://xxx.com/api/list</code></p></blockquote></blockquote><p> </p><h4 id="_2-cors" tabindex="-1">2.CORS <a class="header-anchor" href="#_2-cors" aria-label="Permalink to &quot;2.CORS&quot;">​</a></h4><blockquote><ol><li>CORS 跨域资源共享网址：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noreferrer">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li><li>服务器端跨域，在服务器端设置可以跨域；</li><li>在服务器进行跨域设置，当请求发起之后，会在响应头中带有 access-control-allow-origin，这个时候浏览器就会解除跨域的限制，从而获取从服务器端响应的内容</li></ol></blockquote><p> </p><h4 id="_3-jsonp" tabindex="-1">3. jsonp <a class="header-anchor" href="#_3-jsonp" aria-label="Permalink to &quot;3. jsonp&quot;">​</a></h4><blockquote><ol><li>事实：</li></ol><blockquote><ol><li>src 和 href 属性天然可以跨域；</li><li>script 也有 src 属性，天然可以跨域（只能是 get 方式），并且通过 script 的 src 属性获取到的内容默认会以 js 语法来解析</li></ol></blockquote></blockquote><blockquote><ol start="2"><li>原理：</li></ol><blockquote><ol><li>jsonp 本质上是利用了 script 标签的 src 属性的天然跨域特性来实现的；</li><li>它向后台接口发起请求，传递一个前台拥有的函数名称，后台服务器响应函数的调用形式，且拼接响应的内容</li></ol></blockquote></blockquote><blockquote><ol start="3"><li>注意：</li></ol><blockquote><ol><li>它和异步对象没有任何的关系；</li><li>由于是属性发起请求，所以只能发起 get 请求；</li><li>它严重的依赖服务器的配合</li></ol></blockquote></blockquote></div>`,6)]))}const b=i(t,[["render",n]]);export{d as __pageData,b as default};
