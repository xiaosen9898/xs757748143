import{_ as t,c as o,a2 as l,o as a}from"./chunks/framework.D3LXhGAZ.js";const c="/xs757748143/imgs/react/reactlifecycle.png",h=JSON.parse('{"title":"React 前置","description":"","frontmatter":{},"headers":[],"relativePath":"sidebar/react/react/start.md","filePath":"sidebar/react/react/start.md"}'),i={name:"sidebar/react/react/start.md"};function r(s,e,d,u,n,p){return a(),o("div",null,e[0]||(e[0]=[l('<h1 id="react-前置" tabindex="-1">React 前置 <a class="header-anchor" href="#react-前置" aria-label="Permalink to &quot;React 前置&quot;">​</a></h1><h2 id="脚手架" tabindex="-1">脚手架 <a class="header-anchor" href="#脚手架" aria-label="Permalink to &quot;脚手架&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>创建项目：</li></ol><blockquote><ol><li>js版：</li></ol><blockquote><ul><li>创建命令：<code>npx create-react-app 项目名称</code></li><li>启动项目：<code>yarn start</code></li></ul></blockquote></blockquote><blockquote><ol start="2"><li>ts版：</li></ol><blockquote><ul><li>创建命令：<code>npx create-react-app 项目名 --template typescript</code></li><li>注意：</li></ul><blockquote><ul><li>src下的react-app-env.d.ts文件不能删（提供类型支持）</li><li>.ts文件中不能写JSX代码，.tsx文件中可以写JSX代码</li></ul></blockquote></blockquote></blockquote></div><p> </p><h2 id="组件的生命周期" tabindex="-1">组件的生命周期 <a class="header-anchor" href="#组件的生命周期" aria-label="Permalink to &quot;组件的生命周期&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><h4 id="_1-创建阶段" tabindex="-1">1. 创建阶段： <a class="header-anchor" href="#_1-创建阶段" aria-label="Permalink to &quot;1. 创建阶段：&quot;">​</a></h4><blockquote><ol><li><code>constructor</code>（执行一次）：初始化数据</li><li><code>render</code>（更新DOM时会再次执行）：渲染/更新DOM</li><li><code>componentDidMount</code>（执行一次）：组件挂载（完成DOM渲染）后，在此发请求，不要在constructor发请求</li></ol></blockquote><h4 id="_2-更新阶段" tabindex="-1">2. 更新阶段： <a class="header-anchor" href="#_2-更新阶段" aria-label="Permalink to &quot;2. 更新阶段：&quot;">​</a></h4><blockquote><ol><li><code>render</code>：渲染UI（与 挂载阶段 是同一个render）（注意： 不能调用setState() ，会造成死循环）每次组件渲染都会触发</li></ol><blockquote><ul><li>渲染UI：与 挂载阶段 是同一个render</li><li>触发时机：每次组件渲染都会触发</li><li>注意：不能调用setState()，会造成死循环</li></ul></blockquote><ol start="2"><li><code>componentDidUpdate(prevProps, prevState)</code>：挂载完成后调用</li></ol><blockquote><ul><li>DOM操作，可以获取到更新后的DOM内容，不要调用setState，会造成死循环</li><li>可以通过判断新值和旧值，实现类似Vue的<code>watch</code>功能</li></ul></blockquote></blockquote><ol start="3"><li><h4 id="卸载阶段" tabindex="-1">卸载阶段： <a class="header-anchor" href="#卸载阶段" aria-label="Permalink to &quot;卸载阶段：&quot;">​</a></h4></li></ol><blockquote><ol><li><code>componentWillUnmount</code>：卸载完成后调用</li></ol><blockquote><ul><li>作用：执行清理工作（比如：清理定时器等）</li></ul></blockquote></blockquote><p> </p><p><img src="'+c+'" alt="生命周期图" data-fancybox=""></p></div>',6)]))}const k=t(i,[["render",r]]);export{h as __pageData,k as default};
