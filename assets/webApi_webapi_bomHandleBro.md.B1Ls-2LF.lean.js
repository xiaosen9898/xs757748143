import{_ as i,c as a,a2 as n,o as t}from"./chunks/framework.D3LXhGAZ.js";const l="/xs757748143/imgs/webApi/requestAnimationFrame.png",E=JSON.parse('{"title":"BOM 浏览器对象模型","description":"","frontmatter":{},"headers":[],"relativePath":"webApi/webapi/bomHandleBro.md","filePath":"webApi/webapi/bomHandleBro.md"}'),e={name:"webApi/webapi/bomHandleBro.md"};function p(h,s,r,k,d,o){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="bom-浏览器对象模型" tabindex="-1">BOM 浏览器对象模型 <a class="header-anchor" href="#bom-浏览器对象模型" aria-label="Permalink to &quot;BOM 浏览器对象模型&quot;">​</a></h1><h2 id="window-对象事件" tabindex="-1">window 对象事件 <a class="header-anchor" href="#window-对象事件" aria-label="Permalink to &quot;window 对象事件&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li><code>window.onload = function(){ script代码 }</code></li></ol><blockquote><ul><li>页面加载事件，等页面上所有资源加载完毕后再执行</li></ul></blockquote><p> </p><ol start="2"><li><code>window.onbeforeunload = function(){ script代码 }</code></li></ol><blockquote><ul><li>页面关闭之前事件，一般用来保存一些重要的数据</li></ul></blockquote></div><p> </p><h2 id="window-全局对象" tabindex="-1">window 全局对象 <a class="header-anchor" href="#window-全局对象" aria-label="Permalink to &quot;window 全局对象&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li><code>window.open()</code>：打开窗口</li></ol><blockquote><p><code>window.open(&#39;https://&#39;, &#39;_self&#39;, &#39;width=400, height=400, top=200, left=200&#39;, true)</code></p><blockquote><ul><li>https://：窗口地址</li><li>_self：窗口名称，默认为当前窗口；_blank：新窗口； _parent：父窗口； _top：最顶层窗口</li><li>width：窗口宽度</li><li>height：窗口高度</li><li>top：窗口距离顶部的距离</li><li>left：窗口距离左侧的距离</li><li>true：窗口是否新开窗；</li></ul></blockquote></blockquote><hr>   <ol start="2"><li><code>window.close()</code>：关闭窗口</li></ol><blockquote><ul><li>页面关闭之前事件，一般用来保存一些重要的数据</li></ul></blockquote><hr>   <ol start="3"><li><code>alert()</code>：弹出提示框；</li></ol><hr>   <ol start="4"><li><code>comfirm()</code>：弹出确认框；</li></ol><hr>   <ol start="5"><li>定时器</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 定时器 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timer1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;每隔1秒执行一次&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 清除定时器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer1)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 延时器 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timer2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1秒后执行&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 清除延时器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer2)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p> </p><p><strong>防抖</strong></p><ol><li>定义：单位时间内，频繁触发一个事件，只执行最后一次</li><li>应用场景：输入框输入事件、窗口大小调整、滚动事件、按钮连续点击</li><li>实现：</li></ol><blockquote><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义一个计时器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回一个闭包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每次调用时清除之前的计时器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置新的计时器，延迟执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, delay);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设我们监听一个输入框的输入事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;search&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> placeholder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;请输入搜索内容&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputEl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;search&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;this---&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> debouncedInput</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(handleInput, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">inputEl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, debouncedInput);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 关于this</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 首先，在防抖函数中，将传入的处理函数的this指向改为防抖函数返回的函数的this</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 然后“const debouncedInput = debounce(handleInput, 500)”，此时的this指向返回的debouncedInput函数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 然后“inputEl.addEventListener(&#39;input&#39;, debouncedInput)”，事件处理函数中的this指向inputEl</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div></blockquote><p> </p><p><strong>节流</strong></p><ol><li>定义：单位时间内，频繁触发某个事件，只执行第一次</li><li>应用场景：滚动事件、窗口大小调整、鼠标移动事件、按钮连续点击</li><li>实现：</li></ol><blockquote><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">interval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 记录上一次执行时间</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> now</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前时间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interval) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 判断是否达到时间间隔</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lastTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新上一次执行时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></blockquote></div><p> </p><h2 id="window-五大对象" tabindex="-1">window 五大对象 <a class="header-anchor" href="#window-五大对象" aria-label="Permalink to &quot;window 五大对象&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><h3 id="_1-window-document" tabindex="-1">1. <code>window.document</code> <a class="header-anchor" href="#_1-window-document" aria-label="Permalink to &quot;1. \`window.document\`&quot;">​</a></h3><ol><li>作用：网页的内容（即 DOM 文档对象模型）</li><li>属性：</li></ol><blockquote><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>document.getElementById(&quot;myElement&quot;)</td><td>通过元素的 id 属性获取页面元素</td></tr><tr><td>document.getElementsByClassName(&quot;myClass&quot;)</td><td>通过类名获取元素，返回一个 html 集合对象</td></tr><tr><td>document.getElementsByTagName(&quot;标签名&quot;)</td><td>通过标签名获取元素，返回一个 html 集合对象</td></tr><tr><td>document.querySelector(&quot;选择器&quot;)</td><td>获取第一个匹配的元素</td></tr><tr><td>document.querySelectorAll(&quot;选择器&quot;)</td><td>获取所有匹配的元素，返回一个 NodeList</td></tr></tbody></table></blockquote><p> </p><h3 id="_2-window-location" tabindex="-1">2. <code>window.location</code> <a class="header-anchor" href="#_2-window-location" aria-label="Permalink to &quot;2. \`window.location\`&quot;">​</a></h3><ol><li>作用：获取地址，包含当前有关 URL 的信息</li><li>属性/方法：</li></ol><blockquote><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>Location.href</td><td>获取或设置页面当前地址</td></tr><tr><td>Location.protocol</td><td>获取或设置地址中的协议部分</td></tr><tr><td>Location.host</td><td>获取或设置地址中的主机名和端口号</td></tr><tr><td>Location.hostname</td><td>获取或设置地址中的主机名</td></tr><tr><td>Location.port</td><td>获取或设置地址中的端口号</td></tr><tr><td>Location.pathname</td><td>获取或设置地址中的路径部分</td></tr><tr><td>Location.search</td><td>获取或设置地址中的参数部分</td></tr><tr><td>Location.hash</td><td>获取或设置地址中的 hash 部分</td></tr><tr><td colspan="2"><strong>方法</strong></td></tr><tr><td>location.assign(&#39;地址&#39;)</td><td>加载新的文档（跳转）</td></tr><tr><td>location.replace(&#39;地址&#39;)</td><td>替换当前文档</td></tr><tr><td>location.reload()</td><td>刷新</td></tr></tbody></table></blockquote><p> </p><h3 id="_3-window-history" tabindex="-1">3. <code>window.history</code> <a class="header-anchor" href="#_3-window-history" aria-label="Permalink to &quot;3. \`window.history\`&quot;">​</a></h3><ol><li>作用：包含用户（在浏览器窗口中）访问过的 URL</li><li>属性：</li></ol><table><thead><tr><th>属性</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>返回浏览器历史列表中的 URL 数量</td><td></td></tr><tr><td colspan="3"><strong>方法</strong></td></tr><tr><td>history.back()</td><td>返回上一个 URL</td><td></td></tr><tr><td>history.forward()</td><td>前进一个 URL</td><td></td></tr><tr><td>History.go()</td><td>传入负整数为后退，正整数为前进</td><td></td></tr><tr><td>History.pushState()</td><td>在历史记录中添加一条记录</td><td>页面不刷新</td></tr><tr><td>History.replaceState()</td><td>替换当前记录</td><td>页面不刷新</td></tr></tbody></table><p> </p><h3 id="_4-window-navigator" tabindex="-1">4. <code>window.navigator</code> <a class="header-anchor" href="#_4-window-navigator" aria-label="Permalink to &quot;4. \`window.navigator\`&quot;">​</a></h3><ol><li>作用：包含有关浏览器的信息</li><li>属性：</li></ol><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>navigator.userAgent</td><td>浏览器用户头部信息，可以用它去判断打开当前页面的是什么浏览器</td></tr></tbody></table><p> </p><h3 id="_5-window-screen" tabindex="-1">5. <code>window.screen</code> <a class="header-anchor" href="#_5-window-screen" aria-label="Permalink to &quot;5. \`window.screen\`&quot;">​</a></h3><ol><li>作用：包含有关客户端显示屏幕的信息</li><li>属性：</li></ol><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>screen.width</td><td>返回显示屏幕的宽</td></tr><tr><td>screen.height</td><td>返回显示屏幕的高</td></tr><tr><td>screen.availWidth</td><td>不含任务栏屏幕的宽</td></tr><tr><td>screen.availHeight</td><td>不含任务栏屏幕的高</td></tr></tbody></table></div><p> </p><h2 id="存储对象" tabindex="-1">存储对象 <a class="header-anchor" href="#存储对象" aria-label="Permalink to &quot;存储对象&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><h3 id="_1-localstorage" tabindex="-1">1. <code>localStorage</code> <a class="header-anchor" href="#_1-localstorage" aria-label="Permalink to &quot;1. \`localStorage\`&quot;">​</a></h3><ol><li>作用：本地永久存储</li><li>方法：</li></ol><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>localStorage.setItem(&#39;键&#39;,&#39;值&#39;)</td><td>存储数据</td></tr><tr><td>localStorage.getItem(&#39;键&#39;)</td><td>读取数据</td></tr><tr><td>localStorage.removeItem(&#39;键&#39;)</td><td>删除数据</td></tr><tr><td>localStorage.clear()</td><td>清空数据</td></tr></tbody></table><p>注意：</p><blockquote><ul><li>localStorage 只能存放字符串格式的数据，存的时候是其他类型的数据，取的时候是字符串；</li><li>永久存储(存到了硬盘中)，除非硬盘坏了，或者手动删除了，不然一直都在（生命周期永久生效）</li></ul></blockquote><p> </p><h3 id="_2-sessionstorage" tabindex="-1">2. <code>sessionStorage</code> <a class="header-anchor" href="#_2-sessionstorage" aria-label="Permalink to &quot;2. \`sessionStorage\`&quot;">​</a></h3><ol><li>作用：本地临时存储</li><li>方法：</li></ol><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>sessionStorage.setItem(&#39;键&#39;,&#39;值&#39;)</td><td>存储数据</td></tr><tr><td>sessionStorage.getItem(&#39;键&#39;)</td><td>读取数据</td></tr><tr><td>sessionStorage.removeItem(&#39;键&#39;)</td><td>删除数据</td></tr><tr><td>sessionStorage.clear()</td><td>清空数据</td></tr></tbody></table><p>注意：</p><blockquote><ul><li>只能存放字符串格式的值；</li><li>临时存储，存在内存中了，如果页面关闭数据就清空了</li><li>sessionStorage 只在同一浏览器窗口或标签页中有效</li><li>跨域的页面无法访问同一会话存储的数据</li></ul></blockquote><p> </p><h4 id="对象类型数据的本地存储问题" tabindex="-1">对象类型数据的本地存储问题 <a class="header-anchor" href="#对象类型数据的本地存储问题" aria-label="Permalink to &quot;对象类型数据的本地存储问题&quot;">​</a></h4><ol><li>背景：本地存储只能存放字符串格式的值</li><li>解决：</li></ol><blockquote><ol><li>存储时：js 对象 → <code>JSON.stringify(obj)</code> → 本地存储</li><li>读取时：本地数据 → <code>JSON.parse(str)</code> → js 对象</li></ol><blockquote><ul><li>json 格式数据</li></ul><blockquote><ol><li>组成：</li></ol><blockquote><ol><li>本质是一个字符串</li><li>最外层只能是[ ]或者</li><li>json 文件中不能写注释</li></ol></blockquote></blockquote><blockquote><ol start="2"><li>特点：键和字符串数据必须要用双引号给引起来</li></ol></blockquote><blockquote><ol start="3"><li>注意：值不能是 undefined 和 function 函数</li></ol></blockquote><blockquote><ol start="4"><li>转换：</li></ol><blockquote><ol><li>json 格式的数据转成 js 对象：JSON.parse()</li><li>js 对象转成 json 格式的数据：JSON.stringify()</li></ol></blockquote></blockquote></blockquote></blockquote><p> </p><h4 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h4><ul><li>在同一域下的多个页面（如页面 A 和页面 B）之间，可以使用 sessionStorage 实现数据共享。sessionStorage 是在同一会话中共享的，页面刷新或页面间跳转不会清除数据，但关闭浏览器或标签页后会清空数据</li></ul></div><p> </p><h2 id="渲染帧" tabindex="-1">渲染帧 <a class="header-anchor" href="#渲染帧" aria-label="Permalink to &quot;渲染帧&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><ol><li>渲染帧：浏览器会不断的对网页进行渲染，通常情况下的速度为每秒渲染 60 次，每一次渲染称之为<strong>一帧</strong>，因此又可以说：浏览器的渲染速率是 60 帧，但这不是一定的，它会受到各种因素的影响，因此，帧率往往会有浮动；</li><li>问题：浮动的帧率就导致一个问题，我们在使用<code>setInterval</code>等计时器实现某些动画效果时，如何才能保证每一帧只执行一次动画效果呢</li></ol><p><img src="`+l+`" alt="效果图" data-fancybox=""></p><ol start="3"><li>解决方案：使用<code>requestAnimationFrame</code>（H5 新增的 API），用于在每一帧渲染<strong>之前</strong>做某些事</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 传入一个回调函数，该函数在下一帧渲染之前自动运行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 通常，可以利用该回调函数，在下一帧渲染前改动元素的状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`raq\`的回调函数仅执行一次，因此，要实现连贯的动画，通常使用下面的代码结构</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 该函数负责在下一帧渲染前，执行一次元素状态变化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> changeOnce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(动画是否应该停止){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    改变元素状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    changeOnce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 改变完成后，继续注册下一针的变化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">changeOnce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></div><p> </p>`,16)]))}const b=i(e,[["render",p]]);export{E as __pageData,b as default};
